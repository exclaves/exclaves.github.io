<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Your site description">
    
    <link rel="shortcut icon" href="https://example.com/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <link rel="stylesheet" href="/css/override.css" />
    <title>Calibrating images from Heimann thermopile arrays</title>
</head>
<body><header id="banner">
    <h2><a href="https://example.com">tracks and traces</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/" title="posts">posts</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li>
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Calibrating images from Heimann thermopile arrays</h1>
        <div>
                <time>December 13, 2016</time>
            </div>
    </header><p>After <a href="http://exclav.es/2016/10/26/talkin-ir/">reading an image off a Heimann thermopile array</a>, the pixel values can be converted to temperature readings through the use of calibration parameters stored on the device. To extract the calibration parameters, it is easiest to first read off the entire EEPROM on the thermopile array, as the Python script below does.</p>
<pre tabindex="0"><code>from periphery import I2C
import pickle

i2c = I2C(&#34;/dev/i2c-1&#34;)
device_address = 0x50
query = [I2C.Message([0x00, 0x00]), I2C.Message([0x00]*8000, read=True)]
i2c.transfer(device_address, query)
pickle.dump(query[1].data, open(&#34;eeprom.p&#34;, &#34;wb&#34;))
</code></pre><p>Then, parameters and calibration values can be extracted from this array, as described in the Heimann datasheet.</p>
<pre tabindex="0"><code>VddComp = eeprom[0x0540:0x0740:2] + (eeprom[0x0541:0x0740:2] &lt;&lt; 8)

ThGrad = eeprom[0x0740:0x0F40:2] + (eeprom[0x0741:0x0F40:2] &lt;&lt; 8)
ThGrad = [tg - 65536 if tg &gt;= 32768 else tg for tg in ThGrad]
ThGrad = np.reshape(ThGrad, (32, 32))
ThGrad[16:,:] = np.flipud(ThGrad[16:,:])

ThOffset = eeprom[0x0F40:0x1740:2] + (eeprom[0x0F41:0x1740:2] &lt;&lt; 8)
ThOffset = np.reshape(ThOffset, (32, 32))
ThOffset[16:,:] = np.flipud(ThOffset[16:,:])

P = eeprom[0x1740::2] + (eeprom[0x1741::2] &lt;&lt; 8)
P = np.reshape(P, (32, 32))
P[16:, :] = np.flipud(P[16:,:])

epsilon = float(eeprom[0x000D])
GlobalGain = eeprom[0x0055] + (eeprom[0x0056] &lt;&lt; 8)
Pmin = eeprom[0x0000:0x0004]
Pmax = eeprom[0x0004:0x0008]
Pmin = struct.unpack(&#39;f&#39;, reduce(lambda a,b: a+b, [chr(p) for p in Pmin]))[0]
Pmax = struct.unpack(&#39;f&#39;, reduce(lambda a,b: a+b, [chr(p) for p in Pmax]))[0]
PixC = (P * (Pmax - Pmin) / 65535. + Pmin) * (epsilon / 100) * float(GlobalGain) / 100

gradScale = eeprom[0x0008]
VddCalib = eeprom[0x0046] + (eeprom[0x0047] &lt;&lt; 8)
Vdd = 3280.0
VddScaling = eeprom[0x004E]

PTATgradient = eeprom[0x0034:0x0038]
PTATgradient = struct.unpack(&#39;f&#39;, reduce(lambda a,b: a+b, [chr(p) for p in PTATgradient]))[0]
PTAToffset = eeprom[0x0038:0x003c]
PTAToffset = struct.unpack(&#39;f&#39;, reduce(lambda a,b: a+b, [chr(p) for p in PTAToffset]))[0]
</code></pre><p>However, while using these parameters to correct the raw data from the sensor results in a better image, there is still significant fixed pattern noise. I think that I must be doing something incorrectly, or have a misunderstanding about the expected result.</p>
<p>The raw sensor data appears as follows &ndash; noisy, and dominated by the ADC readout block noise.</p>
<p><img src="/images/2016-12-13/uncorrected.png" alt="Raw sensor data"></p>
<p>Temperature compensation can be performed by using the <code>ThGrad</code> and <code>ThOffset</code> calibration parameters.</p>
<pre tabindex="0"><code>def t_comp(a):
    comp = np.zeros((32,32))

    for i in range(8):
        # calculate ambient temperature
        Ta = np.mean(a[1][i]) * PTATgradient + PTAToffset

        # temperature compensated voltage
        comp[(i*4):(i+1)*4,:] = ((ThGrad[(i*4):(i+1)*4,:] * Ta) / pow(2, gradScale)) + ThOffset[(i*4):(i+1)*4,:]

    Vcomp = np.reshape(a[0],(32, 32)) - comp
    
    return Vcomp
</code></pre><p>This is clearly very important, as it results in a significantly improved image. You can now see the rough outline of a warm object (my face).</p>
<p><img src="/images/2016-12-13/vcomp.png" alt="Temperature compensated sensor data"></p>
<p>However, the next step, which compensates for the supply voltage, does not further improve the image. In fact, it worsens the fixed pattern noise.</p>
<pre tabindex="0"><code>def vdd_comp(Vdd, Vcomp):
    VVddComp = np.zeros((32,32))
    for i in range(16):
        for j in range(32):
            VVddComp[i,j] = Vcomp[i,j] - (VddComp[(j+i*32) % 128] * (Vdd - float(VddCalib)/10))/pow(2, VddScaling)

    for i in range(16,32):
        for j in range(32):
            VVddComp[i,j] = Vcomp[i,j] - (VddComp[((j+i*32) % 128) + 128] * (Vdd - float(VddCalib)/10))/pow(2, VddScaling)
    
    return VVddComp
</code></pre><p><img src="/images/2016-12-13/vvddcomp.png" alt="Vdd compensated sensor data"></p>
<p>I am not sure why this is, or what can be done to further clean up these images.</p>
<p>The sensor also has the capability to read out voltages &ldquo;blind,&rdquo; capturing just the electrical offsets. Subtracting these offsets from the raw sensor data produces a usable image, without fixed pattern noise, though it does have a significant random noise component, as expected from a difference image. Due to this noise, and quantization noise, I do not believe that this method would be usable for imaging through a <a href="http://exclav.es/2016/09/29/low-cost-gas-camera/">MWIR filter</a>.</p>
</article>

        </main><footer id="footer">
    Logan Williams
</footer>

<script type="text/javascript" src="/js/lightbox.js"></script>
<link rel="stylesheet" href="/css/lightbox.css">
<script type="text/javascript" src="/js/accordion.js"></script>
<script type="text/javascript">
    var els = document.getElementsByTagName("img");
    for (var i = 0; i < els.length; i++) {
        var el = els[i];
        el.style.transform = "rotate(" + ((Math.random()-0.5)*2) +  "deg)";
    }

    var els = document.getElementsByClassName("inaturalist");
    for (var i = 0; i < els.length; i++) {
        var el = els[i];
        el.style.transform = "rotate(" + ((Math.random()-0.5)*1.5) +  "deg)";
    }
</script></body>
</html>
