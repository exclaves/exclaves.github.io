<!DOCTYPE html>
<html><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="in progress. blog of Logan Williams/subject.space.">
    
    <link rel="shortcut icon" href="http://localhost:1313/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <meta property="og:url" content="http://localhost:1313/2016/07/15/phase-based-frame-interpolation-a-julia-implementation/">
  <meta property="og:site_name" content="tracks and traces">
  <meta property="og:title" content="Phase-based frame interpolation, a Julia implementation">
  <meta property="og:description" content="In this post, I’ll show how we can use Julia and my multi-scale image decomposition library, Pyramids.jl, to implement Phase-Based Frame Interpolation for Video, an algorithm from CVPR 2015. This assumes some familiarity with complex steerable pyramids.
The paper The paper describes an algorithm for interpolating between video frames, with applications from smoother slow-motion video to creative animation effects.
The algorithm itself is fairly straightforward. First, two complex steerable pyramids are constructed from the two reference frames.">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-07-15T00:00:00+00:00">
    <meta property="article:modified_time" content="2016-07-15T00:00:00+00:00">

    <meta name="twitter:card" content="summary"><meta name="twitter:title" content="Phase-based frame interpolation, a Julia implementation">
<meta name="twitter:description" content="In this post, I&rsquo;ll show how we can use Julia and my multi-scale image decomposition library, Pyramids.jl, to implement Phase-Based Frame Interpolation for Video, an algorithm from CVPR 2015. This assumes some familiarity with complex steerable pyramids.
The paper The paper describes an algorithm for interpolating between video frames, with applications from smoother slow-motion video to creative animation effects.
The algorithm itself is fairly straightforward. First, two complex steerable pyramids are constructed from the two reference frames.">


    <link rel="stylesheet" href="/css/override.css" />
    <title>Phase-based frame interpolation, a Julia implementation</title>
    <script defer data-domain="exclav.es" src="https://plausible.io/js/script.js"></script>
</head>
<body><header id="banner">
    <h2><a href="http://localhost:1313/">tracks and traces</a></h2>
    <nav>
            <a href="http://subject.space">← back to portfolio</a>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>Phase-based frame interpolation, a Julia implementation</h1>
        <div>
                <time>July 15, 2016</time>
            </div>
    </header><p>In this post, I&rsquo;ll show how we can use Julia and my multi-scale image decomposition library, <a href="https://github.com/loganwilliams/Pyramids.jl">Pyramids.jl</a>, to implement <a href="https://www.disneyresearch.com/publication/phasebased/"><em>Phase-Based Frame Interpolation for Video</em></a>, an algorithm from CVPR 2015. This assumes some familiarity with <a href="http://www.cns.nyu.edu/~eero/STEERPYR/">complex steerable pyramids</a>.</p>
<h2 id="the-paper">The paper</h2>
<p>The <a href="https://s3-us-west-1.amazonaws.com/disneyresearch/wp-content/uploads/20150605230239/Phase-Based-Frame-Interpolation-for-Video-Paper.pdf">paper</a> describes an algorithm for interpolating between video frames, with applications from smoother slow-motion video to creative animation effects.</p>
<p>The algorithm itself is fairly straightforward. First, two complex steerable pyramids are constructed from the two reference frames. The method rests on two observations:</p>
<ul>
<li>As image structure is encoded primarily by phase, interpolating the <em>phase</em> of each pixel produces a much higher quality result. <em>However, this only works if the phase is correctly unwrapped.</em></li>
<li>Inherent ambiguity in phase unwrapping can be resolved by looking at the phase of pixels at <em>larger spatial scales.</em></li>
</ul>
<p><img src="/images/2016-07-15/algorithm.png" alt="Algorithm summary"></p>
<p>In the &ldquo;shiftCorrection&rdquo; step, the phase of each pixel is compared to the phase of a pixel at the same location from the next larger spatial scale. Multiples of 2π are added to the pixel&rsquo;s phase to unwrap it to the correct absolute phase. If the unwrapped phase and the phase from the larger spatial scale differ in an ambiguous way, the phase from the larger spatial scale is used instead. As this starts from the largest scale and runs up the pyramid, it is possible that a top level pixel will be using phase information from the broadest spatial scale. By doing this,</p>
<p>In the &ldquo;adjustPhase&rdquo; step, consistency is insured between the interpolated phase and the phase of the reference frames (i.e., with α = 1, we should compute exactly the second reference frame.) This is done by adding a multiple of 2π to the original phase that most closely matches the corrected phase from the previous step.</p>
<p>In this way, the algorithm computes a consistent, unwrapped phase for each pixel. Now, we can simply interpolate phase and magnitude between the two frames, and reconstruct the image from the interpolated pyramid.</p>
<h2 id="the-julia-implementation">The Julia implementation</h2>
<p>Now, let&rsquo;s look at how to implement this algorithm in Julia. First, we will include the libraries we will need, define a new pyramid type that we will use to denote a pyramid containing image phase alone.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=setup.jl"></script>

<p>Next, we must load the images that we will be interpolating between (&ldquo;frame_0.jpg&rdquo; and &ldquo;frame_1.jpg&rdquo;), extract just the luminance component by converting the image to <a href="https://en.wikipedia.org/wiki/Lab_color_space">Lab color space</a> and generate a complex steerable pyramid using the <code>ImagePyramid</code> constructor. Note that unlike traditional complex steerable pyramids, we are using a scale factor &gt; 0.5, which results in a significantly over complete basis. This has been shown to produce significantly higher quality results for this and similar algorithms.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=loading.jl"></script>

<p>This accomplishes the step I have labeled &ldquo;A&rdquo; in the algorithm overview above.</p>
<h3 id="computing-the-phase-difference">Computing the phase difference</h3>
<p>The next significant step, labeled &ldquo;B&rdquo; simply requires computing the difference in phase between each pixel of two pyramids. This looks like the following:</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=phase_difference.jl"></script>

<p>This simply iterates through each level of the two input pyramids, and create a third pyramid (of type <code>PhasePyramid</code>) which stores the difference in phase.</p>
<h3 id="correcting-the-phase-difference">Correcting the phase difference</h3>
<p>The next step is labeled &ldquo;C,&rdquo; and is the most significant part of the algorithm. Here, we will use phase information from larger spatial scales of the image in order to resolve phase ambiguities at higher levels. Let&rsquo;s take a look.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=shift_correction.jl"></script>

<p>Notice that the phase of each level is scaled by the pyramid scale factor, as well as interpolated to match the number of pixels. Also note that anything that hints at ambiguity or inaccuracy (phase shifts too large or phase shifts that don&rsquo;t match larger spatial scales) results in falling back on the phase shift of the larger spatial scale.</p>
<h3 id="adjusting-the-phase-difference">Adjusting the phase difference</h3>
<p>The last significant step in the algorithm, &ldquo;D,&rdquo; requires adjusting the corrected phase to ensure consistency with the original calculated phase delta. Analogous to how we unwrapped the phase in <code>shift_correction</code>, we will add or subtract factors of 2π in order to produce a phase shift consistent with the original value but as close as possible to the corrected one.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=adjust_phase.jl"></script>

<h3 id="interpolating-and-blending-pyramids">Interpolating and blending pyramids</h3>
<p>With the new, unwrapped phase difference computed, we are now able to compute the interpolated complex steerable pyramid. The pyramid amplitudes are interpolated linearly between the two pyramids, and the phase is of course the original phase + alpha * the unwrapped phase difference. To avoid ghosting, a single high frequency phase residual is used only.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=blend_and_interpolate.jl"></script>

<h3 id="rendering-output">Rendering output</h3>
<p>Finally, we produce our output image. Notice that only the luminance channel uses the phase based interpolation method &ndash; simpler, significantly faster linear interpolation suffices for the chrominance channels, as our visual system is far less sensitive to issues like ghosting and sharpness loss in these channels.</p>
<script src="https://gist.github.com/loganwilliams/14027cab9c57ef5286f7eda3794d1f8b.js?file=generate_output.jl"></script>

<h2 id="results">Results</h2>
<p>So, does this algorithm work? What do the results look like? To start, let&rsquo;s look at naive (linear) interpolation between two test frames:</p>
<p><img src="/images/2016-07-15/naive_example.gif" alt="Linear interpolated test frame"></p>
<p>Notice the significant ghosting in the interpolated frame. Phase-based interpolation produces this result:</p>
<p><img src="/images/2016-07-15/interpolated_example.gif" alt="Phase interpolated test frame"></p>
<p>A significant improvement! (Though notice that there are some low-frequency artifacts visible in the interpolated frame.)</p>
<p>Now, let&rsquo;s try a more complicated scene. Here&rsquo;s linear interpolation:</p>
<p><img src="/images/2016-07-15/tree_alpha_c_0.6.png" alt="Linear interpolated forest frame"></p>
<p>And here&rsquo;s phase-based interpolation:</p>
<p><img src="/images/2016-07-15/tree_alpha_0.6.png" alt="Phase interpolated forest frame"></p>
<p>Again, phase-based was much more successful at preserving structure and sharpness without ghosting. Notice especially the branches in the center-left and bottom-right.</p>
<p>However, also notice that the phase-based algorithm performs poorly in the bottom-left, where the movement of the branches was too large for adequate phase recovery. Still, even in this case, the blurring artifacts are arguably less severe than the ghosting visible in the linear implementation.</p>
<p><em>n.b. This is a personal project, and all code is released for research purposes only. Contact The Disney Company for more information about licensing the IP contained in the linked CVPR paper.</em></p>
</article>

        </main><footer id="footer">
    Logan Williams
</footer>

<script type="text/javascript" src="/js/lightbox.js"></script>
<link rel="stylesheet" href="/css/lightbox.css">
<script type="text/javascript" src="/js/accordion.js"></script>
<script type="text/javascript">
    var els = document.getElementsByTagName("img");
    for (var i = 0; i < els.length; i++) {
        var el = els[i];
        el.style.transform = "rotate(" + ((Math.random()-0.5)*2) +  "deg)";
    }

    var els = document.getElementsByClassName("inaturalist");
    for (var i = 0; i < els.length; i++) {
        var el = els[i];
        el.style.transform = "rotate(" + ((Math.random()-0.5)*1.5) +  "deg)";
    }
</script></body>
</html>
